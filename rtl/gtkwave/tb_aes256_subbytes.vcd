$date
	Mon Nov  3 16:25:16 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_aes256_subbytes $end
$var wire 128 ! state_out [127:0] $end
$var reg 1 " mode $end
$var reg 128 # state_in [127:0] $end
$var integer 32 $ errors [31:0] $end
$var integer 32 % test_count [31:0] $end
$scope module dut $end
$var wire 1 " mode_i $end
$var wire 128 & state_i [127:0] $end
$var wire 128 ' state_o [127:0] $end
$scope begin subbytes_gen[0] $end
$var parameter 2 ( i $end
$upscope $end
$scope begin subbytes_gen[1] $end
$var parameter 2 ) i $end
$upscope $end
$scope begin subbytes_gen[2] $end
$var parameter 3 * i $end
$upscope $end
$scope begin subbytes_gen[3] $end
$var parameter 3 + i $end
$upscope $end
$scope begin subbytes_gen[4] $end
$var parameter 4 , i $end
$upscope $end
$scope begin subbytes_gen[5] $end
$var parameter 4 - i $end
$upscope $end
$scope begin subbytes_gen[6] $end
$var parameter 4 . i $end
$upscope $end
$scope begin subbytes_gen[7] $end
$var parameter 4 / i $end
$upscope $end
$scope begin subbytes_gen[8] $end
$var parameter 5 0 i $end
$upscope $end
$scope begin subbytes_gen[9] $end
$var parameter 5 1 i $end
$upscope $end
$scope begin subbytes_gen[10] $end
$var parameter 5 2 i $end
$upscope $end
$scope begin subbytes_gen[11] $end
$var parameter 5 3 i $end
$upscope $end
$scope begin subbytes_gen[12] $end
$var parameter 5 4 i $end
$upscope $end
$scope begin subbytes_gen[13] $end
$var parameter 5 5 i $end
$upscope $end
$scope begin subbytes_gen[14] $end
$var parameter 5 6 i $end
$upscope $end
$scope begin subbytes_gen[15] $end
$var parameter 5 7 i $end
$upscope $end
$upscope $end
$scope begin exhaustive_test $end
$var integer 32 8 byte_val [31:0] $end
$var integer 32 9 inv_sbox_errors [31:0] $end
$var integer 32 : sbox_errors [31:0] $end
$upscope $end
$scope task check_inverse_property $end
$var reg 128 ; decrypted [127:0] $end
$var reg 128 < encrypted [127:0] $end
$var reg 128 = original_state [127:0] $end
$var reg 256 > test_name [255:0] $end
$upscope $end
$scope task check_subbytes $end
$var reg 128 ? expected [127:0] $end
$var reg 1 @ test_mode $end
$var reg 256 A test_name [255:0] $end
$var reg 128 B test_state [127:0] $end
$var integer 32 C byte_errors [31:0] $end
$var integer 32 D i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111 7
b1110 6
b1101 5
b1100 4
b1011 3
b1010 2
b1001 1
b1000 0
b111 /
b110 .
b101 -
b100 ,
b11 +
b10 *
b1 )
b0 (
$end
#5440000
$dumpvars
b10000 D
b0 C
b10110111111000010101000101100010100010101110110100101010011010101011111101110001010110001000000010011100111101001111001111000111 B
b10100100110000101101110011001000110111101101101001000000111001101110100011000010111010001100101001000000011001000100000001011010010000001000100011001010110001101110010011110010111000001110100 A
1@
b100000111000000111000010101011110011110101001110010101010110001111010000101100010111100011101000011100101110100111111000110001 ?
b101001001100001011011100110010001101111011011010010000001110011011101000110000101110100011001010010000000110010 >
b10110111111000010101000101100010100010101110110100101010011010101011111101110001010110001000000010011100111101001111001111000111 =
b10101001111110001101000110101010011111100101010111100101000000100000100010100011011010101100110111011110101111110000110111000110 <
b10110111111000010101000101100010100010101110110100101010011010101011111101110001010110001000000010011100111101001111001111000111 ;
b0 :
b0 9
b100000000 8
b10110111111000010101000101100010100010101110110100101010011010101011111101110001010110001000000010011100111101001111001111000111 '
b10101001111110001101000110101010011111100101010111100101000000100000100010100011011010101100110111011110101111110000110111000110 &
b11001 %
b0 $
b10101001111110001101000110101010011111100101010111100101000000100000100010100011011010101100110111011110101111110000110111000110 #
1"
b10110111111000010101000101100010100010101110110100101010011010101011111101110001010110001000000010011100111101001111001111000111 !
$end
#5540000
